import { GoogleGenAI, Type } from "@google/genai";
import { AgentRole, PlanStep } from "../types";
import { runPythonCode } from "./pythonService";
import { searchArxiv } from "./arxivService";

// Helper to get AI instance
const getAI = () => new GoogleGenAI({ apiKey: process.env.API_KEY });

// Helper to clean code markdown
const cleanCode = (text: string): string => {
  // 1. Try to find content within ```python ... ``` or ``` ... ```
  const markdownMatch = text.match(/```(?:python)?\s*([\s\S]*?)```/i);
  if (markdownMatch) {
    return markdownMatch[1].trim();
  }

  // 2. If no markdown, aggressively look for code-like patterns
  // Find the first occurrence of common Python keywords at the start of a line
  const codeStartMatch = text.match(/^(?:import|from|def|class|#)\s/m);
  if (codeStartMatch && codeStartMatch.index !== undefined) {
    return text.substring(codeStartMatch.index).trim();
  }

  // 3. Fallback: Return text but try to strip common "Here is..." prefixes if possible
  return text.replace(/^Here is .*?:/i, '').trim(); 
};

/**
 * Agent 1: Planner
 */
export const generatePlan = async (userPrompt: string): Promise<PlanStep[]> => {
  const ai = getAI();
  const systemInstruction = `
    You are a Senior Material Informatics Architect. 
    Analyze the user's request and break it down into a linear, logical workflow.
    
    Roles:
    - DATA_GATHERER: Fetches research data from ArXiv (using internal API).
    - ENV_SETUP: Configures the analysis environment.
    - CODE_GENERATOR: Writes and runs Python simulation/analysis code using the gathered data.
    - RESULT_ANALYZER: Interprets the output of the simulation.
    - DOCUMENTATION: Compiles the final report.

    Strictly use these roles.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-3-flash-preview",
    contents: userPrompt,
    config: {
      systemInstruction,
      responseMimeType: "application/json",
      responseSchema: {
        type: Type.ARRAY,
        items: {
          type: Type.OBJECT,
          properties: {
            description: { type: Type.STRING },
            assignedAgent: { 
              type: Type.STRING, 
              enum: [
                "DATA_GATHERER", 
                "ENV_SETUP", 
                "CODE_GENERATOR", 
                "RESULT_ANALYZER", 
                "DOCUMENTATION"
              ] 
            },
          },
          required: ["description", "assignedAgent"],
        },
      },
    },
  });

  const rawSteps = JSON.parse(response.text || "[]");
  
  return rawSteps.map((step: any, index: number) => ({
    id: `step-${Date.now()}-${index}`,
    description: step.description,
    assignedAgent: step.assignedAgent as AgentRole,
    status: 'pending',
  }));
};

/**
 * Agent 3: Data Gatherer (JS-based Fallback for reliability)
 */
export const executeDataGathering = async (taskDescription: string): Promise<{ output: string; code: string; isGeneric: boolean }> => {
  const ai = getAI();
  
  try {
    // 1. Extract keywords for search
    const keywordResponse = await ai.models.generateContent({
      model: "gemini-3-flash-preview",
      contents: `Task: ${taskDescription}\n\nGenerate a single, precise search query string for ArXiv to find relevant papers. Return ONLY the query string (e.g., "graphene conductivity"). Do not include quotes.`,
    });
    
    const query = keywordResponse.text?.trim() || "material science";

    // 2. Execute Search via JS Service (Robust Fallback)
    const papers = await searchArxiv(query);

    if (papers.length === 0) {
       return { 
          output: "No papers found on ArXiv for query: " + query, 
          code: "# No code executed (No results)", 
          isGeneric: true 
       };
    }

    // 3. Format Output
    let formattedOutput = `Search Query: "${query}"\n\n`;
    papers.forEach(p => {
        formattedOutput += `Title: ${p.title}\n`;
        formattedOutput += `PDF Link: ${p.link}\n`; // Arxiv ID is often the link, or we use the link field
        formattedOutput += `Summary: ${p.summary.substring(0, 300)}...\n`;
        formattedOutput += `---\n`;
    });

    // We pretend this was generated by code to satisfy the UI, or just return a comment
    const pseudoCode = `# Executed via ArXiv API (JavaScript Bridge)\n# Query: ${query}\n# Results: ${papers.length} papers fetched.`;

    return { output: formattedOutput, code: pseudoCode, isGeneric: false };

  } catch (err: any) {
    console.error("Data Gathering Failed:", err);
    return { 
        output: "Data gathering failed due to network or API issues.", 
        code: "# Error in execution", 
        isGeneric: true 
    };
  }
};

/**
 * Agent 4: Environment Setup
 */
export const executeEnvSetup = async (taskDescription: string, contextData: string): Promise<string> => {
  return `
# Pyodide Environment
The system is running a browser-based Python environment (Pyodide).
Available packages:
- numpy
- pandas
- scipy
- matplotlib

Environment initialized and ready for execution.
  `;
};

/**
 * Agent 5: Code Generator & Executor
 */
export const executeCodeGeneration = async (taskDescription: string, contextData: string): Promise<{ code: string; output: string }> => {
  const ai = getAI();
  const systemInstruction = `
    You are a Senior Python Developer.
    Write Python code to solve the user's task.
    
    Constraints:
    1. Use 'numpy', 'pandas', 'scipy'.
    2. Use the data provided in the Context (ArXiv results) as hardcoded variables/lists in the code.
    3. **CRITICAL**: PRINT the final results to stdout using print().
    4. Return ONLY the valid Python code. No markdown formatting, no backticks, no conversational filler.
    5. If plotting, focus on numerical outputs first.
    6. Ensure the code is complete and has no syntax errors.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-3-pro-preview",
    contents: `Task: ${taskDescription}\nContext (Data/Env): ${contextData}`,
    config: { systemInstruction },
  });

  const code = cleanCode(response.text || "");

  // Auto-execute
  const { output, error } = await runPythonCode(code);

  const fullOutput = output + (error ? `\n[Stderr]: ${error}` : "");
  return { code, output: fullOutput };
};

/**
 * Agent 6: Result Analyzer
 */
export const executeAnalysis = async (taskDescription: string, contextData: string): Promise<string> => {
  const ai = getAI();
  const systemInstruction = `
    You are a Principal Material Scientist.
    Analyze the Execution Output provided.
    
    1. If the output contains data, interpret it physically.
    2. Verify if the results align with the ArXiv papers found earlier.
    3. Use LaTeX for math ($...$).
    4. Provide actionable insights.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-3-pro-preview",
    contents: `Task: ${taskDescription}\n\nContext (Code & Execution Output): ${contextData}`,
    config: { systemInstruction },
  });

  return response.text || "Analysis failed.";
};

/**
 * Agent 7: Documentation
 */
export const executeDocumentation = async (taskDescription: string, allArtifacts: string): Promise<string> => {
  const ai = getAI();
  const systemInstruction = `
    You are a Technical Writer.
    Compile a final report.
    Use LaTeX for math.
    Clearly state sources (ArXiv links if available).
    If data was generic/simulated, explicitly state that limitation.
  `;

  const response = await ai.models.generateContent({
    model: "gemini-3-flash-preview",
    contents: `Task: ${taskDescription}\nFull Project Context: ${allArtifacts}`,
    config: { systemInstruction },
  });

  return response.text || "Documentation failed.";
};
